# docker-compose.yml
# Configuration Docker Compose optimisée pour la production ATMR

services:
  # Base de données PostgreSQL
  postgres:
    image: postgres:15-alpine
    container_name: atmr-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-atmr_db}
      POSTGRES_USER: ${POSTGRES_USER:-atmr_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-atmr_password}
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - atmr-network
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}",
        ]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 60s
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: "1.0"
        reservations:
          memory: 512M
          cpus: "0.5"

  # Redis pour Celery
  redis:
    image: redis:7-alpine
    container_name: atmr-redis
    restart: unless-stopped
    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    networks:
      - atmr-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: "0.5"
        reservations:
          memory: 256M
          cpus: "0.25"

  # Backend API (Production)
  backend:
    image: ${DOCKER_IMAGE:-docker.io/djasiqi/atmr-backend}:${DOCKER_TAG:-latest}
    container_name: atmr-backend
    restart: unless-stopped
    # Variables d'environnement chargées depuis GitHub Secrets via workflow
    environment:
      # Configuration Flask
      FLASK_ENV: production
      FLASK_APP: app.py

      # Base de données
      DATABASE_URL: postgresql://${POSTGRES_USER:-atmr_user}:${POSTGRES_PASSWORD:-atmr_password}@postgres:5432/${POSTGRES_DB:-atmr_db}

      # Redis/Celery
      CELERY_BROKER_URL: redis://redis:6379/0
      CELERY_RESULT_BACKEND: redis://redis:6379/0

      # Optimisations PyTorch
      OMP_NUM_THREADS: 2
      MKL_NUM_THREADS: 2
      OPENBLAS_NUM_THREADS: 2
      NUMEXPR_NUM_THREADS: 2

      # Sécurité
      SECRET_KEY: ${SECRET_KEY:-your-secret-key-change-in-production}
      JWT_SECRET_KEY: ${JWT_SECRET_KEY:-your-jwt-secret-key-change-in-production}
      APP_ENCRYPTION_KEY_B64: ${APP_ENCRYPTION_KEY_B64}

      # Logging
      LOG_LEVEL: ${LOG_LEVEL:-INFO}

      # API Configuration
      API_LEGACY_ENABLED: "false"  # Désactiver API legacy pour éviter conflit endpoint specs
      API_DOCS: "off"  # Désactiver Swagger UI en production

      # ML Models
      ML_MODELS_PATH: /app/data/ml
      RL_MODELS_PATH: /app/data/rl

    volumes:
      - backend_logs:/app/logs
      - backend_data:/app/data
      - backend_cache:/app/cache
      # Les modèles ML/RL sont inclus dans l'image Docker
    ports:
      - "5000:5000"
    networks:
      - atmr-network
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test:
        [
          "CMD",
          "python",
          "-c",
          "import urllib.request; urllib.request.urlopen('http://localhost:5000/health', timeout=5)",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: "2.0"
        reservations:
          memory: 1G
          cpus: "1.0"

  # Worker Celery
  celery-worker:
    image: ${DOCKER_IMAGE:-docker.io/djasiqi/atmr-backend}:${DOCKER_TAG:-latest}
    container_name: atmr-celery-worker
    restart: unless-stopped
    command: celery -A celery_app.celery worker --loglevel=info --concurrency=2
    environment:
      # Même configuration que le backend
      FLASK_ENV: production
      DATABASE_URL: postgresql://${POSTGRES_USER:-atmr_user}:${POSTGRES_PASSWORD:-atmr_password}@postgres:5432/${POSTGRES_DB:-atmr_db}
      CELERY_BROKER_URL: redis://redis:6379/0
      CELERY_RESULT_BACKEND: redis://redis:6379/0

      # Optimisations PyTorch pour le worker
      OMP_NUM_THREADS: 1
      MKL_NUM_THREADS: 1
      OPENBLAS_NUM_THREADS: 1
      NUMEXPR_NUM_THREADS: 1

      LOG_LEVEL: ${LOG_LEVEL:-INFO}
      ML_MODELS_PATH: /app/data/ml
      RL_MODELS_PATH: /app/data/rl
      APP_ENCRYPTION_KEY_B64: ${APP_ENCRYPTION_KEY_B64}
    volumes:
      - backend_logs:/app/logs
      - backend_data:/app/data
      - backend_cache:/app/cache
      # Les modèles ML/RL sont inclus dans l'image Docker
    networks:
      - atmr-network
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: "1.0"
        reservations:
          memory: 512M
          cpus: "0.5"

  # Beat Celery (planificateur)
  celery-beat:
    image: ${DOCKER_IMAGE:-docker.io/djasiqi/atmr-backend}:${DOCKER_TAG:-latest}
    container_name: atmr-celery-beat
    restart: unless-stopped
    command: celery -A celery_app.celery beat --loglevel=info
    environment:
      FLASK_ENV: production
      DATABASE_URL: postgresql://${POSTGRES_USER:-atmr_user}:${POSTGRES_PASSWORD:-atmr_password}@postgres:5432/${POSTGRES_DB:-atmr_db}
      CELERY_BROKER_URL: redis://redis:6379/0
      CELERY_RESULT_BACKEND: redis://redis:6379/0
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
      APP_ENCRYPTION_KEY_B64: ${APP_ENCRYPTION_KEY_B64}
    volumes:
      - backend_logs:/app/logs
      - celery_beat_data:/app/celerybeat-schedule
    networks:
      - atmr-network
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: "0.25"
        reservations:
          memory: 128M
          cpus: "0.1"

  # Flower (monitoring Celery) - Optionnel
  flower:
    image: ${DOCKER_IMAGE:-docker.io/djasiqi/atmr-backend}:${DOCKER_TAG:-latest}
    container_name: atmr-flower
    restart: unless-stopped
    command: celery -A celery_app.celery flower --port=5555
    environment:
      CELERY_BROKER_URL: redis://redis:6379/0
      CELERY_RESULT_BACKEND: redis://redis:6379/0
    ports:
      - "5555:5555"
    networks:
      - atmr-network
    depends_on:
      - redis
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: "0.25"

  # Nginx (reverse proxy) - Optionnel
  # DÉSACTIVÉ : nécessite nginx/nginx.conf sur le serveur
  # Pour activer : décommentez et assurez-vous que nginx/nginx.conf existe
  # nginx:
  #   image: nginx:alpine
  #   container_name: atmr-nginx
  #   restart: unless-stopped
  #   ports:
  #     - "80:80"
  #     - "443:443"
  #   volumes:
  #     - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
  #     - ./nginx/ssl:/etc/nginx/ssl:ro
  #     - nginx_logs:/var/log/nginx
  #   networks:
  #     - atmr-network
  #   depends_on:
  #     - backend
  #   deploy:
  #     resources:
  #       limits:
  #         memory: 128M
  #         cpus: "0.25"

# Volumes persistants
volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  backend_logs:
    driver: local
  backend_data:
    driver: local
  backend_cache:
    driver: local
  celery_beat_data:
    driver: local
  nginx_logs:
    driver: local

# Réseau privé
networks:
  atmr-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
