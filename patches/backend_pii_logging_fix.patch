--- /dev/null
+++ b/backend/shared/logging_utils.py
@@ -0,0 +1,65 @@
+"""
+Utilitaires pour masquer les données sensibles (PII) dans les logs
+Conformité GDPR-like
+"""
+import re
+import logging
+from typing import Any, Dict
+
+# Patterns à masquer
+EMAIL_PATTERN = re.compile(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b')
+PHONE_PATTERN = re.compile(r'\+?\d[\d\s\-\(\)]{6,20}\d')
+IBAN_PATTERN = re.compile(r'\b[A-Z]{2}\d{2}[A-Z0-9]{10,30}\b')
+
+def mask_email(email: str) -> str:
+    """
+    Masque email: john.doe@example.com → j***@e***.com
+    """
+    if not email or '@' not in email:
+        return email
+    
+    local, domain = email.rsplit('@', 1)
+    domain_parts = domain.split('.')
+    
+    masked_local = local[0] + '***' if len(local) > 0 else '***'
+    masked_domain_name = domain_parts[0][0] + '***' if len(domain_parts[0]) > 0 else '***'
+    masked_domain = masked_domain_name + '.' + '.'.join(domain_parts[1:])
+    
+    return f"{masked_local}@{masked_domain}"
+
+def mask_phone(phone: str) -> str:
+    """
+    Masque téléphone: +41 22 123 45 67 → +41 ** *** ** 67
+    """
+    if not phone:
+        return phone
+    
+    digits = re.sub(r'\D', '', phone)
+    if len(digits) < 4:
+        return '***'
+    
+    # Garder préfixe pays + 2 derniers chiffres
+    return f"{phone[:3]} ** *** ** {digits[-2:]}"
+
+def mask_iban(iban: str) -> str:
+    """
+    Masque IBAN: CH65 0900 0000 1234 5678 9 → CH** **** **** **** **89
+    """
+    if not iban or len(iban) < 8:
+        return iban
+    
+    return f"{iban[:2]}** **** **** **** **{iban[-2:]}"
+
+def sanitize_log_data(data: Any) -> Any:
+    """
+    Nettoie récursivement les données sensibles dans dict/str
+    """
+    if isinstance(data, dict):
+        return {k: sanitize_log_data(v) for k, v in data.items()}
+    
+    if isinstance(data, (list, tuple)):
+        return [sanitize_log_data(item) for item in data]
+    
+    if isinstance(data, str):
+        # Remplacer patterns sensibles
+        sanitized = EMAIL_PATTERN.sub(lambda m: mask_email(m.group(0)), data)
+        sanitized = PHONE_PATTERN.sub(lambda m: mask_phone(m.group(0)), sanitized)
+        sanitized = IBAN_PATTERN.sub(lambda m: mask_iban(m.group(0)), sanitized)
+        return sanitized
+    
+    return data
+
+class PIIFilter(logging.Filter):
+    """Filtre logging pour masquer PII automatiquement"""
+    
+    def filter(self, record: logging.LogRecord) -> bool:
+        # Masquer dans le message
+        if hasattr(record, 'msg') and isinstance(record.msg, str):
+            record.msg = sanitize_log_data(record.msg)
+        
+        # Masquer dans args
+        if hasattr(record, 'args') and record.args:
+            record.args = tuple(sanitize_log_data(arg) for arg in record.args)
+        
+        return True

--- a/backend/app.py
+++ b/backend/app.py
@@ -233,11 +233,18 @@
         )
 
     # 7) Logging
     app_log_level = getattr(logging, os.getenv("APP_LOG_LEVEL", "INFO").upper(), logging.INFO)
     app.logger.setLevel(app_log_level)
+    
+    # ✅ Ajout filtre PII si activé
+    if os.getenv("MASK_PII_LOGS", "true").lower() == "true":
+        from shared.logging_utils import PIIFilter
+        for handler in app.logger.handlers:
+            handler.addFilter(PIIFilter())
+    
     logging.getLogger("werkzeug").setLevel(
         getattr(logging, os.getenv("WERKZEUG_LOG_LEVEL", "ERROR").upper(), logging.ERROR)
     )

--- a/backend/routes/auth.py
+++ b/backend/routes/auth.py
@@ -207,7 +207,9 @@
         try:
             data = request.get_json()
-            app_logger.info(f"Données reçues dans /auth/register : {data}")
+            # ✅ Ne pas logger les données brutes (contient password)
+            from shared.logging_utils import sanitize_log_data
+            app_logger.info(f"Register attempt: {sanitize_log_data({'email': data.get('email'), 'username': data.get('username')})}")
 
             schema = UserSchema()
             _loaded = schema.load(data)

