--- a/frontend/src/utils/apiClient.js
+++ b/frontend/src/utils/apiClient.js
@@ -1,5 +1,6 @@
 // frontend/src/utils/apiClient.js
 import axios from "axios";
+import { getRefreshToken } from "../hooks/useAuthToken";
 
 let apiBase =
   process.env.REACT_APP_API_BASE_URL || process.env.REACT_APP_API_URL || "/api";
@@ -28,6 +29,11 @@
   timeout: 30000,
 });
 
+// ✅ Flag pour éviter boucle infinie refresh
+let isRefreshing = false;
+let failedQueue = [];
+
+const processQueue = (error, token = null) => {
+  failedQueue.forEach(prom => {
+    if (error) {
+      prom.reject(error);
+    } else {
+      prom.resolve(token);
+    }
+  });
+  failedQueue = [];
+};
+
 export const logoutUser = () => {
   localStorage.removeItem("authToken");
+  localStorage.removeItem("refreshToken");
   localStorage.removeItem("user");
   localStorage.removeItem("public_id");
   window.location.href = "/login";
@@ -60,25 +66,69 @@
   return cfg;
 });
 
 apiClient.interceptors.response.use(
   (res) => res,
-  (error) => {
+  async (error) => {
     const status = error?.response?.status;
     const cfg = error?.config || {};
     
     // Message sympa pour 429 (limiter)
     if (status === 429) {
       console.warn(
         "Vous avez effectué trop de requêtes. Merci de patienter un peu."
       );
     }
     
-    // Ne pas déconnecter automatiquement si c'est une requête de refresh token
-    // ou si l'option skipAuthRedirect est définie
-    if (status === 401 && !cfg.skipAuthRedirect && !cfg.url?.includes('/auth/refresh-token')) {
-      logoutUser();
+    // ✅ Gestion 401 avec refresh automatique
+    if (status === 401 && !cfg.skipAuthRedirect) {
+      const refreshToken = getRefreshToken();
+      
+      // Si pas de refresh token ou déjà en train de refresh une requête /auth/refresh-token
+      if (!refreshToken || cfg.url?.includes('/auth/refresh-token')) {
+        logoutUser();
+        return Promise.reject(error);
+      }
+      
+      // Si déjà en train de refresh, mettre en queue
+      if (isRefreshing) {
+        return new Promise((resolve, reject) => {
+          failedQueue.push({ resolve, reject });
+        }).then(token => {
+          cfg.headers.Authorization = `Bearer ${token}`;
+          return apiClient(cfg);  // Retry requête originale
+        }).catch(err => {
+          return Promise.reject(err);
+        });
+      }
+      
+      // Premier 401 → tenter refresh
+      isRefreshing = true;
+      
+      try {
+        const response = await apiClient.post('/auth/refresh-token', {}, {
+          headers: {
+            Authorization: `Bearer ${refreshToken}`
+          },
+          skipAuthRedirect: true  // Éviter boucle
+        });
+        
+        const newToken = response.data.access_token;
+        localStorage.setItem('authToken', newToken);
+        
+        // Process queued requests
+        processQueue(null, newToken);
+        
+        // Retry requête originale
+        cfg.headers.Authorization = `Bearer ${newToken}`;
+        return apiClient(cfg);
+        
+      } catch (refreshError) {
+        processQueue(refreshError, null);
+        logoutUser();
+        return Promise.reject(refreshError);
+      } finally {
+        isRefreshing = false;
+      }
     }

     // Pas de fallback automatique vers /api/v1: on reste sur la vérité du backend
     return Promise.reject(error);
   }
 );

--- a/frontend/src/hooks/useAuthToken.js
+++ b/frontend/src/hooks/useAuthToken.js
@@ -1,8 +1,13 @@
 export const getAccessToken = () => {
   return localStorage.getItem('authToken');
 };
 
+export const getRefreshToken = () => {
+  return localStorage.getItem('refreshToken');
+};
+
 export default function useAuthToken() {
   return {
-    token: getAccessToken()
+    token: getAccessToken(),
+    refreshToken: getRefreshToken()
   };
 }

