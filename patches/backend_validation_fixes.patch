--- a/backend/models/booking.py
+++ b/backend/models/booking.py
@@ -227,10 +227,6 @@
             "patient_name": _as_str(self.customer_name),
         }
 
-    @staticmethod
-    def auto_geocode_if_needed(_booking):
-        return False
-
     # Validations
     @validates('user_id')
     def validate_user_id(self, _key, user_id):

--- a/backend/models/invoice.py
+++ b/backend/models/invoice.py
@@ -84,7 +84,7 @@
         Index("ix_invoice_status", "company_id", "status"),
         Index("ix_invoice_due_date", "due_date"),
         CheckConstraint('total_amount >= 0', name='chk_invoice_amount_positive'),
+        CheckConstraint('balance_due >= 0', name='chk_invoice_balance_nonneg'),
+        CheckConstraint('amount_paid >= 0', name='chk_invoice_paid_nonneg'),
     )
     
     def __repr__(self):

--- a/backend/models/payment.py
+++ b/backend/models/payment.py
@@ -13,6 +13,7 @@
 from sqlalchemy import Enum as SAEnum
 from sqlalchemy.orm import relationship, validates
 
 from ext import db
-from .enums import PaymentStatus
+from .enums import PaymentStatus, PaymentMethod
 from .base import _as_float, _iso
 
@@ -33,9 +34,11 @@
     updated_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now(), onupdate=func.now())
 
+    # ‚úÖ Utiliser PaymentMethod de enums au lieu de d√©finition inline
     method = Column(
-        SAEnum('credit_card', 'paypal', 'bank_transfer', 'cash', name='payment_method'),
-        nullable=False
+        SAEnum(PaymentMethod, name='payment_method_v2'),
+        nullable=False,
+        default=PaymentMethod.BANK_TRANSFER
     )
     status = Column(
         SAEnum(PaymentStatus, name="payment_status"),
@@ -88,11 +91,15 @@
 
     @validates('method')
     def validate_method(self, _key, method):
-        allowed = {'credit_card', 'paypal', 'bank_transfer', 'cash'}
         if isinstance(method, str):
-            method = method.strip()
-        if method not in allowed:
-            raise ValueError(f"M√©thode de paiement invalide. Autoris√©es : {', '.join(sorted(allowed))}")
+            try:
+                method = PaymentMethod(method.lower())
+            except ValueError:
+                try:
+                    method = PaymentMethod[method.upper()]
+                except KeyError:
+                    raise ValueError(f"M√©thode invalide. Autoris√©es : {[m.value for m in PaymentMethod]}")
+        if not isinstance(method, PaymentMethod):
+            raise ValueError("Type PaymentMethod attendu")
         return method

--- a/backend/services/qrbill_service.py
+++ b/backend/services/qrbill_service.py
@@ -40,13 +40,19 @@
                 
                 if institution and institution.is_institution:
                     debtor_name = institution.institution_name or 'Institution'
-                    debtor_street = institution.billing_address or institution.contact_address or 'Adresse non renseign√©e'
-                    # Extraire code postal et ville de l'adresse si possible
-                    debtor_pcode = '1200'
-                    debtor_city = 'Gen√®ve'
+                    debtor_street = institution.billing_address
+                    debtor_pcode = institution.billing_zip or institution.domicile_zip
+                    debtor_city = institution.billing_city or institution.domicile_city
+                    
+                    # ‚úÖ Validation stricte: adresse obligatoire pour QR-bill
+                    if not debtor_street or not debtor_pcode or not debtor_city:
+                        raise ValueError(
+                            f"Adresse incompl√®te pour institution {invoice.bill_to_client_id}. "
+                            "QR-bill requiert adresse compl√®te (rue, code postal, ville)."
+                        )
                 else:
-                    debtor_name = 'Institution'
-                    debtor_street = 'Adresse non renseign√©e'
-                    debtor_pcode = '1200'
-                    debtor_city = 'Gen√®ve'
+                    raise ValueError(
+                        f"Client {invoice.bill_to_client_id} n'est pas marqu√© comme institution"
+                    )
             else:
                 # üë§ Facturation directe : d√©biteur = client (avec m√™me logique que le PDF)
@@ -54,12 +60,17 @@
                 
                 # R√©cup√©rer l'adresse avec priorit√©s multiples
-                debtor_street = 'Adresse non renseign√©e'
-                debtor_pcode = '1200'
-                debtor_city = 'Gen√®ve'
+                debtor_street = None
+                debtor_pcode = None
+                debtor_city = None
                 
                 # Priorit√© 1: Adresse du domicile
                 if hasattr(client, 'domicile_address') and client.domicile_address:
                     debtor_street = client.domicile_address
                     if hasattr(client, 'domicile_zip') and client.domicile_zip:
                         debtor_pcode = client.domicile_zip
@@ -81,6 +92,14 @@
                     if len(parts) >= 4:
                         # Ville
                         debtor_city = parts[3]
+                
+                # ‚úÖ Validation stricte
+                if not debtor_street or not debtor_pcode or not debtor_city:
+                    raise ValueError(
+                        f"Adresse client incompl√®te pour facture {invoice.invoice_number}. "
+                        "QR-bill suisse requiert adresse compl√®te. "
+                        "Veuillez compl√©ter l'adresse du client avant g√©n√©ration."
+                    )

