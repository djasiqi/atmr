name: Backend Tests

permissions:
  contents: read
  actions: read

on:
  push:
    branches: [main, develop, audit/**]
    paths:
      - "backend/**"
      - ".github/workflows/backend-tests.yml"
  workflow_dispatch: # Permet de d√©clencher manuellement le workflow
  pull_request:
    branches: [main, develop]
    paths:
      - "backend/**"

jobs:
  lint:
    name: Lint (Ruff + MyPy + Flake8 + Vulture)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: backend/requirements.txt

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libcairo2-dev libffi-dev pkg-config

      - name: Install dependencies
        run: |
          cd backend
          python -m pip install --upgrade pip
          pip install ruff mypy vulture flake8
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi

      - name: Ruff lint
        run: |
          cd backend
          ruff check . --output-format=github

      - name: Ruff format
        run: |
          cd backend
          ruff format .

      - name: Flake8 check
        run: |
          cd backend
          flake8 .

      - name: MyPy type check
        run: |
          cd backend
          mypy --install-types --non-interactive --ignore-missing-imports \
            --explicit-package-bases \
            models/ routes/ services/ tasks/ shared/

      - name: Check dead code (vulture)
        run: |
          cd backend
          vulture . \
            --min-confidence 80 \
            --sort-by-size \
            --exclude venv,__pycache__,migrations,htmlcov,.pytest_cache,temp_*,instance,uploads,static/qrcodes,scripts/profiling,data/ml,data/rl

  test:
    name: Tests (pytest)
    runs-on: ubuntu-latest

    # ‚úÖ Variables d'environnement au niveau du job pour √©viter les connexions "root"
    env:
      DATABASE_URL: postgresql://test:test@localhost:5432/atmr_test
      PGHOST: localhost
      PGPORT: 5432
      PGUSER: test
      PGPASSWORD: test
      PGDATABASE: atmr_test
      REDIS_URL: redis://localhost:6379/0
      FLASK_CONFIG: testing
      SECRET_KEY: test-secret-key
      JWT_SECRET_KEY: test-jwt-secret
      APP_ENCRYPTION_KEY_B64: MDEyMzQ1Njc4OWFiY2RlZjAxMjM0NTY3ODlhYmNkZWY
      API_LEGACY_ENABLED: "false"
      PYTHONPATH: ${{ github.workspace }}
      SOCKETIO_ASYNC_MODE: threading
      SKIP_SOCKETIO: "true"
      SKIP_ROUTES_INIT: "true"

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: atmr_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U test -d atmr_test"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: backend/requirements.txt

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libcairo2-dev libffi-dev pkg-config

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov coverage
          # D√©pendances de test
          pip install factory-boy freezegun
          # D√©pendances base de donn√©es
          pip install psycopg2-binary flask-migrate
          # D√©pendances ML/RL
          pip install torch gymnasium optuna
          if [ -f backend/requirements.txt ]; then
            pip install -r backend/requirements.txt
          fi
          if [ -f backend/requirements-dev.txt ]; then
            pip install -r backend/requirements-dev.txt
          fi

      - name: Wait for PostgreSQL to be ready
        run: |
          echo "‚è≥ Attente que PostgreSQL soit pr√™t..."
          for i in $(seq 1 30); do
            PGPASSWORD=test psql -h localhost -U test -d atmr_test -c 'SELECT 1' > /dev/null 2>&1 && break
            echo "  Tentative $i/30..."
            sleep 1
          done
          PGPASSWORD=test psql -h localhost -U test -d atmr_test -c 'SELECT 1' || exit 1
          echo "‚úÖ PostgreSQL est pr√™t"

      - name: Show Alembic heads (diagnostic)
        env:
          FLASK_APP: backend.wsgi
        run: |
          cd backend
          echo "üìã Liste des heads Alembic:"
          flask db heads || true
          echo ""

      - name: Run database migrations
        env:
          FLASK_APP: backend.wsgi
        shell: bash
        run: |
          cd backend
          set -o errexit -o nounset -o pipefail -x
          echo "üîÑ Ex√©cution des migrations de base de donn√©es..."
          echo "üìã Alembic heads before upgrade:"
          flask db heads || true
          # Run the upgrade (use 'heads' to handle multiple heads until merge migration is created)
          if ! flask db upgrade heads 2>&1 | tee /tmp/alembic_upgrade.log; then
            echo "‚ùå Erreur lors de l'ex√©cution des migrations"
            echo "---- Diagnostics (upgrade failed) - Log d'erreur ----"
            sed -n '1,200p' /tmp/alembic_upgrade.log || true
            echo "---- Diagnostics (upgrade failed) - √âtat actuel ----"
            flask db current || true
            flask db heads || true
            flask db history | sed -n '1,200p' || true
            echo "Listing migrations/versions:"
            ls -la migrations/versions || true
            echo "---- Contenu des fichiers de migration ----"
            shopt -s nullglob
            for f in migrations/versions/*.py; do
              [ -e "$f" ] || continue
              echo "---- $f ----"
              sed -n '1,200p' "$f"
            done
            exit 1
          fi
          echo "‚úÖ Migrations ex√©cut√©es avec succ√®s"

      - name: Run pytest with coverage
        run: |
          # Lancer pytest depuis la racine pour que les imports 'backend' fonctionnent
          pytest backend/tests -v --cov=backend --cov-report=xml:backend/coverage.xml --cov-report=html:backend/htmlcov --cov-report=term-missing

      # ‚úÖ 3.1: V√©rifier couverture globale ‚â• 70% (bloquant)
      - name: Check global coverage >= 70%
        run: |
          cd backend
          echo "üìä V√©rification couverture globale >= 70%..."
          python scripts/check_coverage.py --coverage-xml coverage.xml --fail-under 70.0 --json coverage_report.json
          echo "‚úÖ Couverture globale >= 70%"

      # ‚úÖ 3.1: V√©rifier couverture modules critiques >= 80%
      - name: Check critical modules coverage >= 80%
        run: |
          echo "üö® V√©rification couverture modules critiques >= 80%..."

          # V√©rifier dispatch modules critiques (d√©j√† v√©rifi√©s s√©par√©ment)
          pytest backend/tests/test_heuristics.py backend/tests/test_solver.py backend/tests/test_autonomous_manager.py \
            --cov=backend/services/unified_dispatch/heuristics.py \
            --cov=backend/services/unified_dispatch/solver.py \
            --cov=backend/services/unified_dispatch/autonomous_manager.py \
            --cov-report=term-missing \
            --cov-fail-under=80 \
            -v

          # V√©rifier autres modules critiques via script
          cd backend
          python scripts/check_coverage.py \
            --coverage-xml coverage.xml \
            --fail-under 80.0 \
            --quiet || true

          # Afficher rapport modules critiques uniquement
          python -c "
          import json
          with open('coverage_report.json') as f:
              report = json.load(f)
          critical_low = report['critical_low_coverage']
          if critical_low:
              print('‚ö†Ô∏è Modules critiques < 80%:')
              for path, stats in list(critical_low.items())[:10]:
                  print(f'  {path}: {stats[\"percentage\"]:.2f}%')
          else:
              print('‚úÖ Tous les modules critiques >= 80%')
          "

          echo "‚úÖ V√©rification modules critiques termin√©e"

      # Upload Codecov d√©sactiv√© jusqu'√† configuration du token
      # Pour activer : ajouter CODECOV_TOKEN dans GitHub Secrets et d√©commenter
      # - name: Upload coverage to Codecov
      #   uses: codecov/codecov-action@v4
      #   if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
      #   with:
      #     file: ./backend/coverage.xml
      #     flags: backend
      #     name: backend-coverage
      #     token: ${{ secrets.CODECOV_TOKEN }}
      #     fail_ci_if_error: false
      #   continue-on-error: true

      - name: Upload coverage artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-coverage-report
          path: |
            backend/htmlcov/
            backend/coverage.xml
            backend/coverage_report.json
          retention-days: 7

  security:
    name: Security Audit (pip-audit)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Installer d√©pendances syst√®me Cairo
        run: |
          sudo apt-get update
          sudo apt-get install -y libcairo2-dev libffi-dev pkg-config

      - name: Install pip-audit
        run: pip install pip-audit

      - name: Run pip-audit
        run: |
          cd backend
          pip-audit --requirement requirements.txt --vulnerability-service osv

      - name: Check for known CVEs
        run: |
          cd backend
          pip-audit --requirement requirements.txt --format json > audit.json
          cat audit.json
        continue-on-error: true

  security-scan:
    name: Security Scan (Bandit + Semgrep)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Create artifacts directory
        run: mkdir -p artifacts

      - name: Install security tools
        run: |
          pip install bandit semgrep safety

      - name: Run Bandit (SAST)
        run: |
          cd backend
          # Utiliser la configuration .bandit pour exclusions
          # G√©n√©rer rapport JSON pour artefacts (ne bloque pas)
          bandit -r . -c .bandit -f json -o ../artifacts/bandit.json || true
          # G√©n√©rer rapport HTML pour visualisation (ne bloque pas)
          bandit -r . -c .bandit -f html -o ../artifacts/bandit.html || true
          # V√©rifier vuln√©rabilit√©s high/critical (bloque si trouv√©es)
          # Warning si vuln√©rabilit√© MEDIUM d√©tect√©e, Fail si HIGH/CRITICAL
          echo "üîç Ex√©cution de Bandit avec configuration .bandit..."
          bandit -r . -c .bandit --severity-level high --confidence-level medium -v || {
            echo "‚ùå Vuln√©rabilit√©s HIGH ou CRITICAL d√©tect√©es par Bandit"
            exit 1
          }
          echo "‚úÖ Aucune vuln√©rabilit√© HIGH ou CRITICAL d√©tect√©e"
        continue-on-error: false

      - name: Run Semgrep (OWASP rules)
        run: |
          cd backend
          # G√©n√©rer rapport JSON (ne bloque pas)
          semgrep --config p/ci --config p/security-audit . --json -o ../artifacts/semgrep.json || true

          # Afficher un r√©sum√© des findings pour am√©liorer la lisibilit√©
          if [ -f ../artifacts/semgrep.json ]; then
            echo "üìä R√©sum√© Semgrep:"
            python3 << 'EOF'
          import json
          import sys

          try:
              with open('../artifacts/semgrep.json', 'r') as f:
                  data = json.load(f)
                  results = data.get('results', [])
                  if results:
                      print(f"   ‚ö†Ô∏è  Trouv√© {len(results)} probl√®me(s) de s√©curit√©")
                      # Afficher les 5 premiers findings
                      for i, r in enumerate(results[:5], 1):
                          check_id = r.get('check_id', 'unknown')
                          path = r.get('path', 'unknown')
                          line = r.get('start', {}).get('line', 'unknown')
                          message = r.get('message', '')[:80]
                          print(f"   {i}. {check_id}")
                          print(f"      üìÅ {path}:{line}")
                          print(f"      üí¨ {message}...")
                      if len(results) > 5:
                          print(f"   ... et {len(results) - 5} autre(s) probl√®me(s)")
                  else:
                      print("   ‚úÖ Aucun probl√®me de s√©curit√© d√©tect√©")
          except Exception as e:
              print(f"   ‚ùå Erreur lors de la lecture du rapport: {e}")
          EOF
          fi

          # V√©rifier r√®gles de s√©curit√© (bloque si trouv√©es)
          semgrep --config p/ci --config p/security-audit . --error
        continue-on-error: false

      - name: Upload security reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-reports
          path: artifacts/*.json
          retention-days: 30

      - name: Upload Bandit HTML report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: bandit-html-report
          path: artifacts/bandit.html
          retention-days: 30

  migrations:
    name: Migrations Check
    runs-on: ubuntu-latest

    # ‚úÖ Variables d'environnement au niveau du job pour √©viter les connexions "root"
    env:
      DATABASE_URL: postgresql://test:test@localhost:5432/atmr_test
      PGHOST: localhost
      PGPORT: 5432
      PGUSER: test
      PGPASSWORD: test
      PGDATABASE: atmr_test
      REDIS_URL: redis://localhost:6379/0
      FLASK_CONFIG: testing
      SECRET_KEY: test-secret-key
      JWT_SECRET_KEY: test-jwt-secret
      APP_ENCRYPTION_KEY_B64: MDEyMzQ1Njc4OWFiY2RlZjAxMjM0NTY3ODlhYmNkZWY
      API_LEGACY_ENABLED: "false"
      PYTHONPATH: ${{ github.workspace }}
      SOCKETIO_ASYNC_MODE: threading
      SKIP_SOCKETIO: "true"
      SKIP_ROUTES_INIT: "true"

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: atmr_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U test -d atmr_test"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: backend/requirements.txt

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libcairo2-dev libffi-dev pkg-config postgresql-client

      - name: Wait for PostgreSQL (migrations job)
        run: |
          echo "‚è≥ Attente que PostgreSQL soit pr√™t..."
          for i in $(seq 1 30); do
            PGPASSWORD=test psql -h localhost -U test -d atmr_test -c 'SELECT 1' > /dev/null 2>&1 && break
            echo "  Tentative $i/30..."
            sleep 1
          done
          PGPASSWORD=test psql -h localhost -U test -d atmr_test -c 'SELECT 1' || exit 1
          echo "‚úÖ PostgreSQL est pr√™t"

      - name: Install dependencies
        run: |
          cd backend
          python -m pip install --upgrade pip
          pip install flask flask-sqlalchemy alembic flask-migrate psycopg2-binary
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi

      - name: Show Alembic heads (diagnostic)
        env:
          FLASK_APP: backend.wsgi
        run: |
          cd backend
          echo "üìã Liste des heads Alembic:"
          flask db heads || true
          echo ""

      - name: Run migrations (upgrade)
        env:
          FLASK_APP: backend.wsgi
        shell: bash
        run: |
          cd backend
          set -o errexit -o nounset -o pipefail -x
          echo "üîÑ Ex√©cution des migrations de base de donn√©es..."
          echo "üìã Alembic heads before upgrade:"
          flask db heads || true
          # Run the upgrade (use 'heads' to handle multiple heads until merge migration is created)
          if ! flask db upgrade heads 2>&1 | tee /tmp/alembic_upgrade.log; then
            echo "‚ùå Erreur lors de l'ex√©cution des migrations"
            echo "---- Diagnostics (upgrade failed) - Log d'erreur ----"
            sed -n '1,200p' /tmp/alembic_upgrade.log || true
            echo "---- Diagnostics (upgrade failed) - √âtat actuel ----"
            flask db current || true
            flask db heads || true
            flask db history | sed -n '1,200p' || true
            echo "Listing migrations/versions:"
            ls -la migrations/versions || true
            echo "---- Contenu des fichiers de migration ----"
            shopt -s nullglob
            for f in migrations/versions/*.py; do
              [ -e "$f" ] || continue
              echo "---- $f ----"
              sed -n '1,200p' "$f"
            done
            exit 1
          fi
          echo "‚úÖ Migrations ex√©cut√©es avec succ√®s"

      - name: Test rollback (downgrade -1)
        env:
          FLASK_APP: backend.wsgi
        run: |
          cd backend
          set -o errexit -o nounset -o pipefail -x

          # Obtenir la r√©vision actuelle
          CURRENT_OUTPUT=$(flask db current 2>/dev/null || echo "")
          CURRENT_REV=$(echo "$CURRENT_OUTPUT" | grep -oE '[a-f0-9]{12,40}' | head -1 || echo "")

          if [ -z "$CURRENT_REV" ]; then
            echo "‚ö†Ô∏è Aucune r√©vision actuelle trouv√©e, skip downgrade test"
            exit 0
          fi

          echo "üìã R√©vision actuelle: $CURRENT_REV"

          # Obtenir l'historique et extraire toutes les r√©visions
          # flask db history liste de la plus ancienne (en bas) √† la plus r√©cente (en haut)
          # Format typique: "revision_id (head) -> description"
          HISTORY_OUTPUT=$(flask db history 2>/dev/null || echo "")

          if [ -z "$HISTORY_OUTPUT" ]; then
            echo "‚ö†Ô∏è Impossible d'obtenir l'historique, skip downgrade test"
            exit 0
          fi

          # Extraire toutes les r√©visions de l'historique (dans l'ordre)
          # Utiliser awk pour extraire la r√©vision pr√©c√©dant CURRENT_REV
          PREV_REV=$(echo "$HISTORY_OUTPUT" | awk -v current="$CURRENT_REV" '
            {
              # Extraire la r√©vision de chaque ligne
              match($0, /[a-f0-9]{12,40}/, rev)
              if (rev[0] != "" && rev[0] == current) {
                # On a trouv√© CURRENT_REV, la r√©vision pr√©c√©dente √©tait stock√©e
                if (prev_rev != "") {
                  print prev_rev
                  exit
                }
              }
              if (rev[0] != "") {
                prev_rev = rev[0]
              }
            }
          ' | head -1 || echo "")

          if [ -z "$PREV_REV" ] || [ "$PREV_REV" = "$CURRENT_REV" ]; then
            echo "‚ö†Ô∏è Pas de r√©vision pr√©c√©dente trouv√©e ou identique √† la r√©vision actuelle"
            echo "   Cela peut arriver si on est √† la premi√®re migration"
            echo "   Skip downgrade test"
            exit 0
          fi

          echo "üîÑ Downgrading from $CURRENT_REV to $PREV_REV"
          if flask db downgrade "$PREV_REV"; then
            echo "‚úÖ Downgrade r√©ussi"
          else
            echo "‚ö†Ô∏è √âchec du downgrade, mais on continue avec l'upgrade"
          fi

          # Re-upgrade apr√®s downgrade test
          echo "üîÑ Re-upgrading to head..."
          flask db upgrade heads || exit 1
          echo "‚úÖ Rollback test r√©ussi"

      - name: Check for pending migrations
        env:
          FLASK_APP: backend.wsgi
        run: |
          cd backend
          # V√©rifier aucune migration auto-d√©tect√©e non commit√©e
          # G√©n√©rer une migration de test pour d√©tecter les changements
          TEST_MIGRATION_FILE="migrations/versions/$(date +%s)_test_pending_check.py"
          flask db revision --autogenerate -m "test_pending_check" > /dev/null 2>&1 || true

          # Trouver le fichier de migration de test cr√©√© (le plus r√©cent)
          LATEST_MIGRATION=$(ls -t migrations/versions/*test_pending_check.py 2>/dev/null | head -1 || echo "")

          if [ -n "$LATEST_MIGRATION" ] && [ -f "$LATEST_MIGRATION" ]; then
            # V√©rifier si la migration contient des changements (pas seulement un fichier vide)
            if grep -q "def upgrade" "$LATEST_MIGRATION" && grep -q "op\." "$LATEST_MIGRATION"; then
              echo "‚ö†Ô∏è Warning: Pending migrations detected!"
              echo "La migration suivante a √©t√© g√©n√©r√©e automatiquement:"
              cat "$LATEST_MIGRATION"
              rm -f "$LATEST_MIGRATION"
              exit 1
            else
              # Migration vide, pas de changements d√©tect√©s
              rm -f "$LATEST_MIGRATION"
              echo "‚úÖ Aucune migration en attente d√©tect√©e"
            fi
          else
            echo "‚úÖ Aucune migration en attente d√©tect√©e"
          fi
